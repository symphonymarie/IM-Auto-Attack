{
  "Auto-Combat": {
    "name": "Auto-Combat",
    "type": "trait",
    "img": "modules/impmal-core/assets/icons/blank.webp",
    "system": {
      "notes": {
        "player": "",
        "gm": ""
      },
      "attack": {
        "type": "melee",
        "characteristic": "",
        "skill": {
          "key": "",
          "specialisation": ""
        },
        "damage": {
          "SL": false,
          "base": "",
          "characteristic": "",
          "ignoreAP": false
        },
        "range": "",
        "traits": {
          "list": []
        },
        "self": false
      },
      "test": {
        "difficulty": "challenging",
        "characteristic": "",
        "skill": {
          "key": "",
          "specialisation": ""
        },
        "self": false
      },
      "roll": {
        "enabled": false,
        "formula": "",
        "label": ""
      }
    },
    "effects": [
      {
        "name": "Auto-Combat",
        "img": "modules/impmal-core/assets/icons/blank.webp",
        "type": "base",
        "system": {
          "transferData": {
            "type": "document",
            "originalType": "document",
            "documentType": "Actor",
            "avoidTest": {
              "value": "none",
              "opposed": false,
              "prevention": true,
              "reversed": false,
              "skill": {}
            },
            "testIndependent": false,
            "equipTransfer": false,
            "selfOnly": false,
            "prompt": false,
            "area": {
              "templateData": {
                "borderColor": null,
                "fillColor": null,
                "texture": null
              },
              "keep": false,
              "aura": {
                "transferred": false,
                "render": false
              },
              "duration": "sustained"
            },
            "zone": {
              "type": "zone",
              "transferred": false,
              "traits": {
                "barrier": false,
                "difficult": false,
                "warpTouched": false
              },
              "skipImmediateOnPlacement": false,
              "keep": false
            }
          },
          "itemTargetData": {
            "ids": [],
            "allItems": false
          },
          "scriptData": [
            {
              "script": "const token = canvas.tokens.controlled[0];\nif (!token) {\n    ui.notifications.warn(\"Please select a token first.\");\n    return;\n}\n\n// Check token disposition\nconst disposition = token.document.disposition;\nconst isHostile = disposition === CONST.TOKEN_DISPOSITIONS.HOSTILE;\n\nlet targetTokens = [];\n\nif (isHostile) {\n    // Hostile tokens target anything that's NOT hostile (players, friendly, neutral)\n    targetTokens = canvas.tokens.placeables.filter(t => {\n        if (!t.actor || t.document.hidden || t.id === token.id) return false;\n        \n        // Target any token that is NOT hostile\n        return t.document.disposition !== CONST.TOKEN_DISPOSITIONS.HOSTILE;\n    });\n} else {\n    // Friendly/neutral tokens target hostile tokens only\n    targetTokens = canvas.tokens.placeables.filter(t => \n        t.actor && \n        t.document.disposition === CONST.TOKEN_DISPOSITIONS.HOSTILE &&\n        !t.document.hidden\n    );\n}\n\nif (targetTokens.length === 0) {\n    ui.notifications.warn(\"No valid targets found.\");\n    return;\n}\n\n// Find nearest target token, using priority to break distance ties\nconst nearest = targetTokens.reduce((closest, t) => {\n    const distance = canvas.grid.measureDistance(token.center, t.center);\n    \n    // If no closest target yet, this one becomes closest\n    if (!closest) {\n        return { token: t, distance, priority: getPriority(t) };\n    }\n    \n    // If this token is closer, it becomes the new closest\n    if (distance < closest.distance) {\n        return { token: t, distance, priority: getPriority(t) };\n    }\n    \n    // If distance is equal, use priority to break tie\n    if (distance === closest.distance) {\n        const currentPriority = getPriority(t);\n        if (currentPriority > closest.priority) {\n            return { token: t, distance, priority: currentPriority };\n        }\n    }\n    \n    return closest;\n}, null);\n\nif (!nearest) {\n    ui.notifications.warn(\"No valid targets found.\");\n    return;\n}\n\n// Target the selected token\nnearest.token.setTarget(true, { user: game.user, releaseOthers: true });\nui.notifications.info(`Targeting ${nearest.token.name}`);\n\n// Get available attacks\nconst actor = token.actor;\nif (!actor) {\n    ui.notifications.error(\"No actor associated with selected token\");\n    return;\n}\n\n// Calculate distance in grid squares more accurately\nconst tokenPosition = token.center;\nconst targetPosition = nearest.token.center;\nconst gridSize = canvas.grid.size;\n\n// Calculate the difference in grid units\nconst dx = Math.abs(tokenPosition.x - targetPosition.x) / gridSize;\nconst dy = Math.abs(tokenPosition.y - targetPosition.y) / gridSize;\n\n// Use the maximum of dx and dy for grid-based distance (chebyshev distance)\nconst gridDistance = Math.max(dx, dy);\n\nconst isWithinOneSquare = gridDistance <= 1;\n\n// Get attacks\nconst meleeAttacks = actor.items.filter(i => i.name.endsWith(\"*\") && !i.name.endsWith(\"*R\"));\nconst rangedAttacks = actor.items.filter(i => i.name.endsWith(\"*R\"));\n\n// Function to execute a random attack\nfunction executeRandomAttack(attacks, attackType) {\n    if (attacks.length === 0) {\n        ui.notifications.warn(`No ${attackType} attacks found.`);\n        return;\n    }\n    \n    // Select one random attack\n    const randomAttack = attacks[Math.floor(Math.random() * attacks.length)];\n    const itemUUID = randomAttack.uuid;\n    game.impmal.utility.rollItemMacro(itemUUID, actor);\n    ui.notifications.info(`Using ${attackType} attack: ${randomAttack.name}`);\n}\n\n// Handle based on distance\nif (isWithinOneSquare) {\n    // Target is within 1 square - use random melee attack\n    executeRandomAttack(meleeAttacks, \"melee\");\n} else {\n    // Target is more than 1 square away - show dialog\n    new Dialog({\n        title: \"Target Out of Range\",\n        content: `\n            <div style=\"padding: 10px;\">\n                <p>Target is ${Math.ceil(gridDistance)} squares away. Choose an action:</p>\n            </div>\n        `,\n        buttons: {\n            continue: {\n                icon: '<i class=\"fas fa-bullseye\"></i>',\n                label: \"Ranged Attack\",\n                callback: () => {\n                    executeRandomAttack(rangedAttacks, \"ranged\");\n                }\n            },\n            cancel: {\n                icon: '<i class=\"fas fa-walking\"></i>',\n                label: \"Cancel and Move\",\n                callback: () => {\n                    ui.notifications.info(\"Attack canceled. You may now move your token.\");\n                }\n            }\n        },\n        default: \"continue\"\n    }).render(true);\n}\n\n// Helper function to assign priority values (players > friendly > neutral)\nfunction getPriority(targetToken) {\n    if (targetToken.actor.hasPlayerOwner) return 3; // Players - highest priority\n    if (targetToken.document.disposition === CONST.TOKEN_DISPOSITIONS.FRIENDLY) return 2;\n    if (targetToken.document.disposition === CONST.TOKEN_DISPOSITIONS.NEUTRAL) return 1;\n    return 0;\n}",
              "label": "Auto Combat Handler",
              "trigger": "startTurn",
              "options": {
                "targeter": false,
                "defending": false,
                "deleteEffect": false
              },
              "async": false
            }
          ],
          "zone": {
            "type": "zone",
            "traits": {},
            "skipImmediateOnPlacement": false
          },
          "sourceData": {
            "test": {}
          },
          "computed": false
        },
        "changes": [],
        "disabled": false,
        "duration": {
          "startTime": null,
          "combat": null,
          "seconds": null,
          "rounds": null,
          "turns": null,
          "startRound": null,
          "startTurn": null
        },
        "description": "",
        "origin": null,
        "tint": "#ffffff",
        "transfer": true,
        "statuses": [],
        "sort": 0,
        "flags": {
          "impmal": {
            "manualEffectKeys": false
          }
        }
      }
    ],
    "flags": {},
    "ownership": {
      "default": 0
    }
  }
}